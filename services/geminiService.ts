import { GoogleGenAI, Modality, Part } from "@google/genai";

const apiKey = process.env.API_KEY;
if (!apiKey) {
  throw new Error("API_KEY environment variable not set");
}
const ai = new GoogleGenAI({ apiKey });

const fileToGenerativePart = (base64: string, mimeType: string): Part => {
  const pureBase64 = base64.split(',')[1];
  return {
    inlineData: {
      data: pureBase64,
      mimeType,
    },
  };
};

export const refineImage = async (
  imageBase64: string,
  maskBase64: string
): Promise<string> => {
  const model = 'gemini-2.5-flash-image-preview';
  const imagePart = fileToGenerativePart(imageBase64, 'image/png');
  const maskPart = fileToGenerativePart(`data:image/png;base64,${maskBase64}`, 'image/png');

  const prompt = "The user has provided an image and a mask. The mask indicates areas to be removed. Please perfectly remove the marked areas, making the background transparent. The unmarked areas of the image should be preserved without any changes.";

  try {
    const response = await ai.models.generateContent({
      model: model,
      contents: { parts: [{ text: prompt }, imagePart, maskPart] },
      config: { responseModalities: [Modality.IMAGE, Modality.TEXT] },
    });

    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData) {
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }
    throw new Error("No image was generated by the model.");
  } catch (error) {
    console.error("Error refining image:", error);
    throw new Error("Failed to refine image with Gemini API.");
  }
};

const studioPrompts: string[] = [
    "Place the product image professionally in a bright, white 3D studio with an infinity curve background. The logo image should be subtly rendered as a large, low-opacity watermark on the floor, appearing as part of the scene with a slight perspective. The final image must be a photorealistic e-commerce shot.",
    "Render the product image standing on a reflective white floor in a minimalist studio. The back wall, which is pure white, should feature a pattern of the tiled logo image, very subtle and low contrast. The lighting should be soft and professional.",
    "Create a clean e-commerce shot. The product is in a white studio. On the wall to the left, the logo is projected softly, slightly out of focus. The product should have a gentle shadow on the floor.",
    "A photorealistic shot of the product in a white room with two walls visible, creating a corner. The logo image is placed on the floor, large and centered, with a perspective effect as if it's painted on the ground. The product is placed on top of it.",
    "Minimalist studio setting. The product is the hero. In the background, on a clean white wall, the logo is rendered as a large, elegant, grey watermark. The overall feel is premium and clean.",
    "A top-down 'flat lay' style shot in a virtual studio. The product is centered on a pure white surface. The logo appears in the four corners of the image, small and with low opacity.",
    "The product is set in a white studio. A single, large version of the logo is placed on the back wall, behind the product. The logo should be semi-transparent and not distract from the product.",
    "Dynamic studio shot. The product is on a white surface. The logo is used to create a subtle pattern on the floor, radiating outwards from the center. The effect should be elegant and modern.",
];

export const generateStudioScenes = async (
  productImageBase64: string,
  logoImageBase64: string
): Promise<string[]> => {
    const model = 'gemini-2.5-flash-image-preview';
    const productPart = fileToGenerativePart(productImageBase64, 'image/png');
    const logoPart = fileToGenerativePart(logoImageBase64, 'image/png');

    const generationPromises = studioPrompts.map(prompt => 
        ai.models.generateContent({
            model,
            contents: { parts: [productPart, logoPart, { text: prompt }] },
            config: { responseModalities: [Modality.IMAGE, Modality.TEXT] }
        }).then(response => {
            for (const candidate of response.candidates ?? []) {
                for (const part of candidate.content.parts) {
                    if (part.inlineData) {
                        return `data:image/png;base64,${part.inlineData.data}`;
                    }
                }
            }
            return null;
        }).catch(err => {
            console.warn(`A scene generation failed for prompt: "${prompt}"`, err);
            return null;
        })
    );

    const results = await Promise.all(generationPromises);
    const successfulResults = results.filter((res): res is string => res !== null);

    if (successfulResults.length === 0) {
        throw new Error("Failed to generate any studio scenes.");
    }

    return successfulResults;
};
